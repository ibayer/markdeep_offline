<!DOCTYPE html><meta charset="utf-8"><textarea class='md'>

    **markdeep**

# markdeep

-   [markdeep/latest](http://casual-effects.com/markdeep/latest/)
-   [markdeep/features](http://casual-effects.com/markdeep/features.md.html)

-   Surround the markdown content with something allowing for uninterpreted
    data (e.g. a `<textarea>`, btw.: are there other constructs in HTML5 for
    "data").  We do not want to have the browser parse/evaluate before we
    arrive!  E.g. just having the following code block should **not** log
    anything.

    ``` html
    <script type="text/javascript">console.log('hi');</script>
    ```

-   Normal markdown would now just render the textarea.  So we call the
    markdeep API on the **unprocess and unparsed** textContent.  Embedded tags
    are parsed after markdown processing not before!

-   This skips css injection and we have to take care of the styling.

!!! warning
    Take care of loose HTML tags.  Opening one unintentionally might brake
    parsing results without indication of error.  Escaping the leading arrow
    (`\<`) is not recognized.  Use the HTML entity `&lt;`.

    Especially, do not accidentally close the `&lt;/textarea>` that keeps the
    text as-is before processing.

# katex

-   [katex/releases](https://github.com/Khan/KaTeX/releases)
-   [katex/supported](https://katex.org/docs/supported.html)

$a$ \(b\)

$$c$$ \[d\]

# pseudocode

-   [pseudocode/features](https://github.com/tatetian/pseudocode.js#features)

``` pseudocode
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$A,p,r$}\COMMENT{comment}
  \IF{$p < r$}
    \STATE $q\gets$ \CALL{Partition}{$A,p,r$}
    \STATE \CALL{Quicksort}{$A, p, q - 1$}
    \STATE \CALL{Quicksort}{$A, q + 1, r$}
  \ENDIF
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
```

# autoloading

HTML tags (script, link and img) with the `pollchange` class are periodically
polled and if changed the full pages reloads.

</textarea><script class='pollchange' src='bootstrap.js'></script>
